# ubernim

This is the documentation of the ubernim commands (separated by preprod features).

## COMMANDS

### UNIMPRJS feature commands:

* **.project** *(since 0.5.4)*
	- specifies the project name and opens the associated block
	- values: any valid identifier
	- example: `.project SomeProject`
* **.defines** *(since 0.5.4)*
	- specifies conditional defines to be added to the project before invokation
	- values: any valid define names in a comma separated fashion
	- example: `.defines SOME_OS,SOMETHING_CUSTOM`
* **.undefines** *(since 0.5.4)*
	- specifies conditional defines to be removed from the project before invokation
	- values: any valid define names in a comma separated fashion
	- example: `.undefines SOME_DEFINES,TO_BE_DROPPED`
* **.main** *(since 0.5.4)*
	- specifies the project file name for a ubernim invokation
	- values: any valid file name (typically a .unim extension file)
	- example: `.main file.unim`
* **.end** *(since 0.5.4)*
	- specifies the end of the current block
	- values: none
	- example: `.end`
* **.make** *(since 0.5.4)*
	- makes the specified project by invoking ubernim
	- values: any existing project name
	- example: `.make SomeProject`

See them working in the *projects* example.

### UNIMCMDS feature commands:

* **.unim:version** *(since 0.2.0)*
	- specifies the minimum version of ubernim required to process this file
	- values: semantic version format (x.x.x)
	- example: `.unim:version 0.3.0`
* **.unim:flush** *(since 0.2.1)*
	- specifies if the current file will emit output as a file
	- values: yes/no (default: yes)
	- note: this is useful for files where compounds, interfaces or protocols are defined and exported
	- example: `.unim:flush no`
* **.unim:mode** *(since 0.3.2)*
	- specifies if the following lines in the file can be not ubernim lines
	- values: free/strict (default: free)
	- note: this is useful to restrict portions or entire files from containing nim code
	- example: `.unim:mode strict`
* **.unim:cleanup** *(since 0.4.3)*
	- specifies if the generated files will be: kept in disk (with 'ignored' value), listed to the console (with 'informed' value) or deleted after all steps are done (with 'performed' value)
	- values: ignored/informed/performed (default: ignored)
	- note: use the 'performed' value if you want, as the ubernim call result, to obtain only the binaries generated by the nim compiler
	- example: `.unim:cleanup performed`
* **.unim:destination** *(since 0.7.0)*
	- specifies the autocatically generated files directory
	- values: any valid directory path
	- note: use this if you want your ubernim files to be separate of the generated .nim (and nim configuration) files
	- example: `.unim:destination src`

See them working in the *coding* example.

### SWITCHES feature commands:

* **.nimc:project** *(since 0.1.0)*
	- specifies the project file name for the nim compile command, if you don't specify any file name the transpile will be done but the nim compiler won't be invoked
	- values: any valid file name (typically a .nim extension file)
	- example: `.nimc:project file.nim`
* **.nimc:config** *(since 0.1.0)*
	- specifies the project configuration file name for the nim compile command, if you don't specify any file name the defines and switches will be passed via command line on compiler invokation
	- values: any valid file name (typically a .nim.cfg extension file)
	- example: `.nimc:config file.nim.cfg`
* **.nimc:define** *(since 0.1.0)*
	- specifies a define name to be passed to the nim compiler
	- values: any valid define name
	- example: `.nimc:define release`
* **.nimc:switch** *(since 0.1.0)*
	- specifies a switch name to be passed to the nim compiler
	- values: any valid switch name
	- example: `.nimc:switch --threads:on`
* **.nimc:minimum** *(since 0.4.2)*
	- specifies the minimum version accepted of the nim compiler
	- values: semantic version format (x.x.x)
	- example: `.nimc:minimum 1.0.6`
* **.nimc:target** *(since 0.4.4)*
	- specifies the target compiler of the nim compiler
	- values: cc, cpp, objc or js (default: cc)
	- example: `.nimc:target cpp`

See them working in the *directives* example.

### SHELLCMD feature commands:

* **.exec** *(since 0.1.0)*
	- specifies a shell command to be executed
	- values: any valid shell command
	- example: `.exec dir`

See them working in the *actions* example.

### FSACCESS feature commands:

* **.write** *(since 0.1.0)*
	- creates a file using the specified name and content
	- values: any valid file name and content
	- example: `.write foo.txt bar`
* **.append** *(since 0.1.0)*
	- appends a file using the specified name and content
	- values: any valid file name and content
	- example: `.append foo.txt !!!`
* **.copy** *(since 0.1.0)*
	- copies a file
	- values: any valid file names
	- example: `.copy foo.txt bar.txt`
* **.move** *(since 0.1.0)*
	- moves or rename a file
	- values: any valid file names
	- example: `.move bar.txt blah.txt`
* **.remove** *(since 0.1.0)*
	- removes a file
	- values: any valid file names
	- example: `.remove blah.txt`
* **.mkdir** *(since 0.1.0)*
	- creates a directory
	- values: any valid directory name
	- example: `.mkdir bin`
* **.cpdir** *(since 0.1.0)*
	- copies a directory
	- values: any valid directory name
	- example: `.cpdir bin out`
* **.rmdir** *(since 0.1.0)*
	- removes a directory
	- values: any valid directory name
	- example: `.rmdir bin`
* **.chdir** *(since 0.1.0)*
	- changes currenty directory to the specified one
	- values: any valid directory name
	- example: `.chdir ..`

See them working in the *actions* example.

### REQUIRES feature commands:

* **.require** *(since 0.1.0)*
	- specifies another ubernim file to be preprocessed, importing all the exported symbols from it to be used in the current one
	- values: any valid file name (since 0.7.6 extension-less file names will be appended with a .unim extension before load)
	- note: the self file, the main project file and .unimp extension files can not be required; also note that .require does not generates a line in the output including the generated .nim file, you have to add it yourself if it is required
	- example: `.require file.unim`
* **.requirable** *(since 0.2.2)*
	- specifies if the current ubernim file can be required from other ubernim file
	- values: yes/no (default: yes)
	- note: the main file is not requirable by default and that can not be changed
	- example: `.requirable no`

See them working in the *coding* example.

### LANGUAGE feature commands:

* **.compound** *(since 0.1.0)*
	- specifies a group of fields that must be present in those that applies it
	- values: any valid identifier
	- example: `.compound BunchOfFields`
* **.interface** *(since 0.1.0)*
	- specifies a group of methods that must be present in those that applies it
	- values: any valid identifier
	- example: `.interface BunchOfMethods`
* **.protocol** *(since 0.1.0)*
	- specifies a group of fields and methods that must be present in those that applies it
	- values: any valid identifier
	- example: `.protocol MyProcotol`
* **.class** *(since 0.1.0)*
	- specifies a new class type
	- values: any valid identifier
	- example: `.class MyClass`
* **.record** *(since 0.1.0)*
	- specifies a new record type
	- values: any valid identifier
	- example: `.record MyRecord`
* **.pragmas** *(since 0.1.0)*
	- specifies one or more pragmas
	- values: any valid pragmas in the regular comma separated fashion (the same you would write inside {. .})
	- example: `.pragmas noSideEffect, deprecated: "use something else"`
* **.applies** *(since 0.1.0)*
	- specifies one or more compounds, interfaces or protocols that will be applied to this protocol, class or record
	- values: any valid existing compounds, interfaces or protocols in a comma separated fashion
	- example: `.applies SomeInterface, SomeCompound`
* **.extends** *(since 0.1.0)*
	- specifies a class or record to extend the current class or record
	- values: any valid existing class or record (type must match)
	- example: `.extends SuperClass`
* **.fields** *(since 0.1.0)*
	- specifies a group of fields
	- values: field defitions after it (in the regular form of identifier:type), check the examples
	- example: `.fields`
* **.methods** *(since 0.1.0)*
	- specifies a group of methods
	- values: method definitions after it (for regular methods like in regular nim, and with a prefix for special methods: `+` for constructors, `>` for setters and `<` for getters -this ones using a field-like definition style-), check the examples
	- example: `.methods`
* **.templates** *(since 0.1.0)*
	- specifies a group of templates
	- values: any valid identifier
	- example: `.templates`
* **.docs** *(since 0.1.0)*
	- specifies the documentation for this item
	- values: any valid documentation content (whatever you would write after regular ## lines) after it
	- example: `.docs`
* **.constructor** *(since 0.1.0)*
	- specifies a new constructor for a class or record implementation
	- values: class name period the regular method definition (any valid identifier plus the arguments inside parenthesis)
	- note: access to parent -if any- is not available in constructors
	- example: `.constructor TestClass.create(something: int, somethingElse: string)`
* **.getter** *(since 0.3.0)*
	- specifies a new property getter for a class or record implementation
	- values: the regular getter -field like- definition (any valid identifier plus the return type)
	- example: `.getter TestClass.prop: string`
* **.setter** *(since 0.3.0)*
	- specifies a new property setter for a class or record implementation
	- values: the regular setter definition (any valid identifier plus the arguments inside parenthesis, and the return type after a colon if any)
	- note: remember to add 'var' before the class name if the setter does actually modify any field value (which typically will)
	- example: `.setter var TestClass.prop(value: string)`
* **.method** *(since 0.1.0)*
	- specifies a new method for a class or record implementation
	- values: the regular method definition (any valid identifier plus the arguments inside parenthesis, and the return type after a colon if any)
	- note: remember to add 'var' before the class name if the setter does actually modify any field value
	- example: `.method TestClass.MyMethod(a: int, b: float): string`
* **.template** *(since 0.1.0)*
	- specifies a new template
	- values: the regular method definition (any valid identifier plus the arguments inside parenthesis, and the return type after a colon if any)
	- example: `.template MyTemplate(a: untyped)`
* **.routine** *(since 0.1.0)*
	- specifies a new routine
	- values: the regular method definition (any valid identifier plus the arguments inside parenthesis, and the return type after a colon if any)
	- example: `.routine MyProcedure(a: int, b: float): string`
* **.code** *(since 0.1.0)*
	- specifies the code for the current block
	- values: any valid nim lines after it
	- example: `.code`
* **.uses** *(since 0.3.3)*
	- specifies one or more imports required by the current block
	- values: any valid nim import in the regular comma separated fashion (except of the from/import syntax that is simplified with a period between the module and the entity)
	- example: `.uses sequtils, strutils.join, json`
* **.member** *(since 0.5.0)*
	- specifies a new member
	- values: any valid member definition (in the regular form of identifier:type)
	- note: it allows to use the var modifier to make the member mutable (by default is immutable)
	- example: `.member var MyField*:int`
* **.value** *(since 0.5.0)*
	- specifies the value for the current member definition
	- values: any valid nim value after it
	- note: if you don't define an immediate value, you'll be force to use a code block to initialize the member
	- example: `.value 123`
* **.end** *(since 0.1.0)*
	- specifies the end of the current block
	- values: none
	- example: `.end`
* **.note** *(since 0.1.0)*
	- specifies a note block that will be emitted as comment lines
	- values: any valid comment content after it
	- example: `.note`
* **.imports** *(since 0.4.0)*
	- specifies an imports block that will be emitted as import/from-import lines
	- values: any valid nim import (except of the from/import syntax that is simplified with a period between the module and the entity)
	- example: `.imports`
* **.exports** *(since 0.4.0)*
	- specifies an exports block that will be emitted as export lines
	- values: any valid nim export
	- example: `.exports`
* **.importing** *(since 0.4.1)*
	- specifies if the imports will be emitted always or once per file
	- values: always/once (default: always, it's more compatible with conditional defines, otherwise you could end up with a required import not being there)
	- note: this also affects the .uses clause of methods, routines, etc
	- example: `.importing once`
* **.exporting** *(since 0.4.1)*
	- specifies if the exports will be emitted always or once per file
	- values: always/once (default: always)
	- example: `.exporting once`
* **.applying** *(since 0.5.0)*
	- specifies a compound, interface or protocol that will be applied to this file
	- values: any valid existing compounds, interfaces or protocols in a comma separated fashion (prior to 0.7.6 only a single one can be specified per clause)
	- note: fields are fulfilled with members, and methods with routines
	- example: `.applying MyInterface, MyProtocol`
* **.push** *(since 0.2.0)*
	- specifies pragmas that will be pushed to the nim's pragma stack
	- values: any valid pragma values you would push in nim
	- example: `.push`
* **.pop** *(since 0.2.0)*
	- specifies a pop from the nim's pragma stack
	- values: none
	- example: `.pop`
* **.pattern** *(since 0.8.0)*
	- specifies a new pattern template
	- values: any valid identifier
	- note: patterns are simple string replace dumb-but-safe templates
	- example: `.pattern MyPattern`
* **.parameters** *(since 0.8.0)*
	- specifies the parameter list for the pattern being defined
	- values: any valid parameter names in a comma separated fashion
	- example: `.parameters $a, $b, $c`
* **.data** *(since 0.8.0)*
	- specifies the template data for the pattern being defined
	- values: any valid nim lines after it
	- example: `.data`
* **.stamp** *(since 0.8.0)*
	- specifies the pattern template and parameters to imprint in the output
	- values: any valid pattern name followed by the parameters values in a comma separated fashion
	- note: spaces before and after a comma are not ignored on purpose so you can insert spaces in the final result as needed; also note that if a parameter is not supplied it will be an empty string as a result; and also note that if you provide more parameters than defined in .parameters then they will be ignored
	- example: `.stamp MyPattern param1,param2,param3`

See them working in the *coding* example.

### TARGETED feature commands:

* **.targeted** *(since 0.5.3)*
	- specifies the target compiler of this block
	- values: cc, cpp, objc or js (default: cc)
	- example: `.targeted cc`
* **.targeted:pass** *(since 0.5.3)*
	- specifies compiler and linker flags
	- values: literal values prefixed with 'to:compiler', 'to:local' and 'to:linker' to what you would pass to 'passC', 'localPassC' and 'passL' pragmas
	- example: `.targeted:pass`
* **.targeted:compile** *(since 0.5.3)*
	- specifies a list of files to compile
	- values: any valid nim value for pragma compile including or not compilation parameters (for example, some .c files)
	- example: `.targeted:compile`
* **.targeted:link** *(since 0.5.3)*
	- specifies a list of files to link
	- values: any valid nim value for pragma link (for example, some .o files)
	- example: `.targeted:link`
* **.targeted:emit** *(since 0.5.3)*
	- specifies code to emit directly
	- values: any valid nim emit block code (for example, regular c code)
	- example: `.targeted:emit`
* **.targeted:end** *(since 0.5.3)*
	- specifies the end of this targeted block
	- values: none
	- example: `.targeted:end`

See them working in the *coding* example.
